from cryptography.hazmat.primitives.asymmetric import x25519
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os
from cryptography.hazmat.primitives import serialization # Added for deserialize_public_key

def generate_keys():
    """
    Generates an X25519 private and public key pair for Diffie-Hellman key exchange.
    Returns:
        tuple: (private_key, public_key) objects.
    """
    private_key = x25519.X25519PrivateKey.generate()
    public_key = private_key.public_key()
    return private_key, public_key

def derive_shared_key(private_key, peer_public_key):
    """
    Derives a shared symmetric key (AES-256 compatible) using HKDF
    from the shared secret obtained via X25519 key exchange.
    Args:
        private_key (x25519.X25519PrivateKey): Your private key.
        peer_public_key (x25519.X25519PublicKey): The other party's public key.
    Returns:
        bytes: A 32-byte (256-bit) derived shared key.
    """
    # Perform the key exchange to get the raw shared secret
    shared_secret = private_key.exchange(peer_public_key)

    # Use HKDF (HMAC-based Key Derivation Function) to derive a strong,
    # cryptographically secure key from the shared secret.
    # This ensures the key is of a fixed length and suitable for AES.
    derived_key = HKDF(
        algorithm=hashes.SHA256(), # Use SHA256 as the hash algorithm
        length=32,                 # Desired key length in bytes (32 bytes = 256 bits for AES-256)
        salt=None,                 # Salt is optional here, but good practice for other contexts
        info=b'handshake data',    # Contextual information to bind the key to this specific use
        backend=default_backend()
    ).derive(shared_secret)
    return derived_key

def aes_encrypt(key, plaintext):
    """
    Encrypts data using AES-256 in GCM (Galois/Counter Mode).
    GCM provides authenticated encryption (confidentiality and integrity).
    Args:
        key (bytes): The 32-byte (256-bit) AES encryption key.
        plaintext (bytes): The data to be encrypted.
    Returns:
        bytes: Concatenated nonce + ciphertext + authentication tag.
    """
    # Generate a unique nonce (Number Used Once) for each encryption operation.
    # GCM recommends a 96-bit (12-byte) nonce.
    nonce = os.urandom(12)

    # Create an AES cipher object with the key and GCM mode
    cipher = Cipher(algorithms.AES(key), modes.GCM(nonce), backend=default_backend())
    encryptor = cipher.encryptor()

    # Encrypt the plaintext
    ciphertext = encryptor.update(plaintext) + encryptor.finalize()

    # The GCM tag (authentication tag) is automatically generated by finalize()
    # and is part of encryptor.tag. We need to prepend the nonce and append the tag
    # to the ciphertext for decryption.
    return nonce + ciphertext + encryptor.tag

def aes_decrypt(key, encrypted_data):
    """
    Decrypts data encrypted with AES-256 in GCM mode.
    Args:
        key (bytes): The 32-byte (256-bit) AES decryption key.
        encrypted_data (bytes): The concatenated nonce + ciphertext + authentication tag.
    Returns:
        bytes: The original plaintext.
    Raises:
        cryptography.exceptions.InvalidTag: If the authentication tag is invalid (data tampered).
    """
    # Extract the nonce (first 12 bytes), ciphertext, and authentication tag (last 16 bytes)
    nonce = encrypted_data[:12]
    ciphertext = encrypted_data[12:-16] # Ciphertext is between nonce and tag
    tag = encrypted_data[-16:]          # Tag is the last 16 bytes

    # Create an AES cipher object with the key, GCM mode, and the received nonce and tag
    cipher = Cipher(algorithms.AES(key), modes.GCM(nonce, tag), backend=default_backend())
    decryptor = cipher.decryptor()

    # Decrypt the ciphertext. If the tag is invalid, an InvalidTag exception will be raised.
    plaintext = decryptor.update(ciphertext) + decryptor.finalize()
    return plaintext

def deserialize_public_key(public_key_bytes):
    """
    Deserializes a public key from PEM format bytes.
    Args:
        public_key_bytes (bytes): The public key in PEM format.
    Returns:
        cryptography.hazmat.primitives.asymmetric.x25519.X25519PublicKey: The deserialized public key object.
    """
    return serialization.load_pem_public_key(public_key_bytes)